[33mcommit 1e06f7a642645616c5d063ea7e4e786801832b2e[m
Author: Rak√©tapingvin <160329754+Raketapingvin@users.noreply.github.com>
Date:   Wed Feb 18 20:24:57 2026 +0100

    SETTINGS & CTR, NETWORK FIX
    
    Basic settings, theme added, scrollbar
    FIXED:
    Notepad key shortcuts and arrow moving.
    
    //UTC +1// 02/18/2026

[1mdiff --git a/Makefile b/Makefile[m
[1mindex 818ef75..48d894b 100644[m
[1m--- a/Makefile[m
[1m+++ b/Makefile[m
[36m@@ -24,4 +24,4 @@[m [mbuild-x86_64: $(x86_64_object_files)[m
 [m
 .PHONY: run[m
 run:[m
[31m-	qemu-system-x86_64 -cdrom dist/x86_64/kernel.iso -device rtl8139 -audiodev pa,id=spk -machine pcspk-audiodev=spk -device piix3-usb-uhci -drive file=disk.img,format=raw,index=0,media=disk[m
[32m+[m	[32mqemu-system-x86_64 -cdrom dist/x86_64/kernel.iso -netdev user,id=net0 -device rtl8139,netdev=net0 -audiodev pa,id=spk -machine pcspk-audiodev=spk -device piix3-usb-uhci -drive file=disk.img,format=raw,index=0,media=disk[m
[1mdiff --git a/src/impl/kernel/drivers/framebuffer.c b/src/impl/kernel/drivers/framebuffer.c[m
[1mindex 002dd81..761e570 100644[m
[1m--- a/src/impl/kernel/drivers/framebuffer.c[m
[1m+++ b/src/impl/kernel/drivers/framebuffer.c[m
[36m@@ -58,23 +58,78 @@[m [muint32_t framebuffer_get_pixel(uint32_t x, uint32_t y) {[m
     return *pixel;[m
 }[m
 [m
[32m+[m[32m<<<<<<< Updated upstream[m
[32m+[m[32m=======[m
[32m+[m[32mvoid framebuffer_swap(void) {[m
[32m+[m[32m    if (fb.base_address == 0 || fb.buffer_size == 0 || !dirty) return;[m
[32m+[m
[32m+[m[32m    // Only copy the dirty rectangle to VRAM[m
[32m+[m[32m    uint32_t x = dirty_x1;[m
[32m+[m[32m    uint32_t y = dirty_y1;[m
[32m+[m[32m    uint32_t w = dirty_x2 - dirty_x1 + 1;[m
[32m+[m[32m    uint32_t h = dirty_y2 - dirty_y1 + 1;[m
[32m+[m
[32m+[m[32m    for (uint32_t row = y; row < y + h; row++) {[m
[32m+[m[32m        uint64_t* dst = (uint64_t*)((uint8_t*)fb.base_address + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint64_t* src = (uint64_t*)(back_buffer + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint32_t qwords = ((w + (x & 1) + 1) / 2);[m
[32m+[m[32m        for (uint32_t i = 0; i < qwords; i++) {[m
[32m+[m[32m            dst[i] = src[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    dirty_reset();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid framebuffer_blit_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h) {[m
[32m+[m[32m    if (fb.base_address == 0) return;[m
[32m+[m
[32m+[m[32m    // Clamp to screen bounds[m
[32m+[m[32m    if (x >= fb.width || y >= fb.height) return;[m
[32m+[m[32m    if (x + w > fb.width) w = fb.width - x;[m
[32m+[m[32m    if (y + h > fb.height) h = fb.height - y;[m
[32m+[m
[32m+[m[32m    // Copy rectangle from back buffer to video memory using 64-bit writes[m
[32m+[m[32m    for (uint32_t row = y; row < y + h; row++) {[m
[32m+[m[32m        uint64_t* dst = (uint64_t*)((uint8_t*)fb.base_address + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint64_t* src = (uint64_t*)(back_buffer + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint32_t qwords = ((w + (x & 1) + 1) / 2);[m
[32m+[m[32m        for (uint32_t i = 0; i < qwords; i++) {[m
[32m+[m[32m            dst[i] = src[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m>>>>>>> Stashed changes[m
 void framebuffer_clear(uint32_t color) {[m
     if (fb.base_address == 0) return;[m
     [m
[31m-    // Naive clear[m
     for (uint32_t y = 0; y < fb.height; y++) {[m
[32m+[m[32m        uint32_t* row = (uint32_t*)(back_buffer + y * fb.pitch);[m
         for (uint32_t x = 0; x < fb.width; x++) {[m
[31m-            framebuffer_put_pixel(x, y, color);[m
[32m+[m[32m            row[x] = color;[m
         }[m
     }[m
[32m+[m[32m    dirty_mark(0, 0);[m
[32m+[m[32m    dirty_mark(fb.width - 1, fb.height - 1);[m
 }[m
 [m
 void framebuffer_draw_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {[m
[31m-    for (uint32_t i = 0; i < h; i++) {[m
[31m-        for (uint32_t j = 0; j < w; j++) {[m
[31m-            framebuffer_put_pixel(x + j, y + i, color);[m
[32m+[m[32m    if (fb.base_address == 0 || w == 0 || h == 0) return;[m
[32m+[m
[32m+[m[32m    // Clamp to screen bounds[m
[32m+[m[32m    if (x >= fb.width || y >= fb.height) return;[m
[32m+[m[32m    if (x + w > fb.width) w = fb.width - x;[m
[32m+[m[32m    if (y + h > fb.height) h = fb.height - y;[m
[32m+[m
[32m+[m[32m    for (uint32_t row = 0; row < h; row++) {[m
[32m+[m[32m        uint32_t* dst = (uint32_t*)(back_buffer + (y + row) * fb.pitch + x * 4);[m
[32m+[m[32m        for (uint32_t col = 0; col < w; col++) {[m
[32m+[m[32m            dst[col] = color;[m
         }[m
     }[m
[32m+[m[32m    dirty_mark(x, y);[m
[32m+[m[32m    dirty_mark(x + w - 1, y + h - 1);[m
 }[m
 [m
 void framebuffer_draw_cursor(uint32_t x, uint32_t y) {[m
[1mdiff --git a/src/impl/kernel/drivers/mouse.c b/src/impl/kernel/drivers/mouse.c[m
[1mindex 0eaa2a0..4369058 100644[m
[1m--- a/src/impl/kernel/drivers/mouse.c[m
[1m+++ b/src/impl/kernel/drivers/mouse.c[m
[36m@@ -38,10 +38,22 @@[m [muint8_t mouse_read_ack() {[m
     return inb(MOUSE_PORT_DATA);[m
 }[m
 [m
[32m+[m[32m// Mouse speed: 0=slow(0.5x), 1=normal(1x), 2=fast(2x)[m
[32m+[m[32mvolatile int mouse_speed_setting = 1;[m
[32m+[m
 static void mouse_process_packet() {[m
     uint8_t flags = mouse_byte[0];[m
[31m-    int8_t x_rel = (int8_t) mouse_byte[1];[m
[31m-    int8_t y_rel = (int8_t) mouse_byte[2];[m
[32m+[m[32m    int32_t x_rel = (int8_t) mouse_byte[1];[m
[32m+[m[32m    int32_t y_rel = (int8_t) mouse_byte[2];[m
[32m+[m
[32m+[m[32m    // Apply speed multiplier[m
[32m+[m[32m    if (mouse_speed_setting == 0) {[m
[32m+[m[32m        x_rel = x_rel / 2;[m
[32m+[m[32m        y_rel = y_rel / 2;[m
[32m+[m[32m    } else if (mouse_speed_setting == 2) {[m
[32m+[m[32m        x_rel = x_rel * 2;[m
[32m+[m[32m        y_rel = y_rel * 2;[m
[32m+[m[32m    }[m
 [m
     mouse_state.x += x_rel;[m
     mouse_state.y -= y_rel;[m
[1mdiff --git a/src/impl/kernel/drivers/rtl8139.c b/src/impl/kernel/drivers/rtl8139.c[m
[1mindex ff21c2b..06e9341 100644[m
[1m--- a/src/impl/kernel/drivers/rtl8139.c[m
[1m+++ b/src/impl/kernel/drivers/rtl8139.c[m
[36m@@ -2,11 +2,12 @@[m
 #include "drivers/pci.h"[m
 #include "util/io.h"[m
 #include "drivers/framebuffer.h"[m
[32m+[m[32m#include "cpu/timer.h"[m
 [m
 #define RTL8139_VENDOR_ID 0x10EC[m
 #define RTL8139_DEVICE_ID 0x8139[m
 [m
[31m-#define RX_BUF_SIZE 8192 + 16 + 1500[m
[32m+[m[32m#define RX_BUF_SIZE (8192 + 16 + 1500)[m
 [m
 // Registers[m
 #define REG_MAC0 0x00[m
[36m@@ -15,25 +16,32 @@[m
 #define REG_TXADDR0 0x20[m
 #define REG_RXBUF 0x30[m
 #define REG_CMD 0x37[m
[31m-#define REG_CAPR 0x38 [m
[32m+[m[32m#define REG_CAPR 0x38[m
[32m+[m[32m#define REG_CBR  0x3A  // Current Buffer address (read pointer for hw)[m
 #define REG_IMR 0x3C // Interrupt Mask Register[m
 #define REG_ISR 0x3E // Interrupt Status Register[m
 #define REG_TCR 0x40 // Transmit Config[m
 #define REG_RCR 0x44 // Receive Config[m
 #define REG_CONFIG1 0x52[m
 [m
[31m-uint32_t io_addr;[m
[31m-uint8_t rx_buffer[RX_BUF_SIZE];[m
[31m-uint8_t mac_addr[6];[m
[32m+[m[32mstatic uint32_t io_addr;[m
[32m+[m[32mstatic int detected = 0;[m
[32m+[m[32mstatic uint8_t rx_buffer[RX_BUF_SIZE] __attribute__((aligned(4)));[m
[32m+[m[32mstatic uint8_t mac_addr[6];[m
[32m+[m[32mstatic uint8_t tx_buf[4][2048] __attribute__((aligned(4)));[m
[32m+[m[32mstatic int cur_tx = 0;[m
[32m+[m[32mstatic uint16_t rx_read_ptr = 0;[m
 [m
 void rtl8139_init() {[m
     struct PciDevice pci_dev = pci_get_device(RTL8139_VENDOR_ID, RTL8139_DEVICE_ID);[m
     [m
     if (pci_dev.vendor_id == 0) {[m
[31m-        // print_str("RTL8139 not found!\n");[m
[32m+[m[32m        detected = 0;[m
         return;[m
     }[m
     [m
[32m+[m[32m    detected = 1;[m
[32m+[m
     // Enable Bus Mastering[m
     pci_enable_bus_mastering(pci_dev);[m
     [m
[36m@@ -60,6 +68,172 @@[m [mvoid rtl8139_init() {[m
     // Enable RE (Receive) and TE (Transmit)[m
     outb(io_addr + REG_CMD, 0x0C);[m
     [m
[32m+[m[32m    // Read MAC address[m
[32m+[m[32m    for (int i = 0; i < 6; i++) {[m
[32m+[m[32m        mac_addr[i] = inb(io_addr + REG_MAC0 + i);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Init TX descriptors[m
[32m+[m[32m    cur_tx = 0;[m
[32m+[m[32m    rx_read_ptr = 0;[m
[32m+[m
     // Draw green square to indicate success[m
     framebuffer_draw_rect(0, 0, 50, 50, 0xFF00FF00);[m
 }[m
[32m+[m
[32m+[m[32mint rtl8139_is_detected() {[m
[32m+[m[32m    return detected;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid rtl8139_get_mac(uint8_t* out) {[m
[32m+[m[32m    for (int i = 0; i < 6; i++) {[m
[32m+[m[32m        out[i] = mac_addr[i];[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Send a raw Ethernet frame. Returns 1 on success, 0 on failure.[m
[32m+[m[32mint rtl8139_send_packet(void* data, uint32_t len) {[m
[32m+[m[32m    if (!detected || len > 1792) return 0;[m
[32m+[m
[32m+[m[32m    // Copy packet data into current TX buffer[m
[32m+[m[32m    uint8_t* src = (uint8_t*)data;[m
[32m+[m[32m    for (uint32_t i = 0; i < len; i++) {[m
[32m+[m[32m        tx_buf[cur_tx][i] = src[i];[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Tell the NIC where the buffer is and how big[m
[32m+[m[32m    outl(io_addr + REG_TXADDR0 + cur_tx * 4, (uint32_t)(uint64_t)tx_buf[cur_tx]);[m
[32m+[m[32m    // Size in bits 0-12, clear OWN bit (bit 13) to start transmission[m
[32m+[m[32m    outl(io_addr + REG_TXSTATUS0 + cur_tx * 4, len & 0x1FFF);[m
[32m+[m
[32m+[m[32m    // Wait for TOK (Transmit OK, bit 15) or timeout[m
[32m+[m[32m    uint64_t start = get_tick_count();[m
[32m+[m[32m    while (1) {[m
[32m+[m[32m        uint32_t status = inl(io_addr + REG_TXSTATUS0 + cur_tx * 4);[m
[32m+[m[32m        if (status & (1 << 15)) break;  // TOK - transmit OK[m
[32m+[m[32m        if (status & (1 << 14)) break;  // TUN - transmit FIFO underrun (still sent in QEMU)[m
[32m+[m[32m        if ((get_tick_count() - start) > 50) return 0; // 500ms timeout[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    cur_tx = (cur_tx + 1) % 4;[m
[32m+[m[32m    return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Check if any packet has been received. Returns length or 0.[m
[32m+[m[32mstatic int rtl8139_check_rx(uint8_t* out_buf, int max_len) {[m
[32m+[m[32m    if (!detected) return 0;[m
[32m+[m
[32m+[m[32m    // Check if buffer is empty[m
[32m+[m[32m    uint8_t cmd = inb(io_addr + REG_CMD);[m
[32m+[m[32m    if (cmd & 0x01) {[m
[32m+[m[32m        // Buffer empty bit is set, nothing to read[m
[32m+[m[32m        // Actually bit 0 of CMD is "Buffer Empty" when read[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Check ISR for ROK[m
[32m+[m[32m    uint16_t isr = inw(io_addr + REG_ISR);[m
[32m+[m[32m    if (!(isr & 0x01)) return 0; // No packet received[m
[32m+[m
[32m+[m[32m    // Clear ROK[m
[32m+[m[32m    outw(io_addr + REG_ISR, 0x01);[m
[32m+[m
[32m+[m[32m    // Read packet header from rx_buffer at rx_read_ptr[m
[32m+[m[32m    // Format: [status(16) | length(16) | packet_data...][m
[32m+[m[32m    uint16_t rx_status = *(uint16_t*)(rx_buffer + rx_read_ptr);[m
[32m+[m[32m    uint16_t rx_len    = *(uint16_t*)(rx_buffer + rx_read_ptr + 2);[m
[32m+[m
[32m+[m[32m    if (!(rx_status & 0x01)) return 0; // ROK bit not set in packet header[m
[32m+[m
[32m+[m[32m    // Sanity check length[m
[32m+[m[32m    if (rx_len < 8 || rx_len > 1792) {[m
[32m+[m[32m        // Bad packet, advance pointer[m
[32m+[m[32m        rx_read_ptr = (inw(io_addr + REG_CBR) + 16) & 0x1FFF;[m
[32m+[m[32m        outw(io_addr + REG_CAPR, rx_read_ptr - 16);[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Copy packet data (skip the 4-byte header)[m
[32m+[m[32m    int copy_len = rx_len - 4; // subtract CRC[m
[32m+[m[32m    if (copy_len > max_len) copy_len = max_len;[m
[32m+[m[32m    for (int i = 0; i < copy_len; i++) {[m
[32m+[m[32m        out_buf[i] = rx_buffer[(rx_read_ptr + 4 + i) % RX_BUF_SIZE];[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Advance read pointer (4-byte header + rx_len, aligned to 4 bytes + 4)[m
[32m+[m[32m    rx_read_ptr = (rx_read_ptr + rx_len + 4 + 3) & ~3;[m
[32m+[m[32m    rx_read_ptr %= RX_BUF_SIZE;[m
[32m+[m[32m    outw(io_addr + REG_CAPR, rx_read_ptr - 16);[m
[32m+[m
[32m+[m[32m    return copy_len;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Send an ARP "who-has" request to the given IP and wait for a reply.[m
[32m+[m[32m// Returns: 1 = got ARP reply (network works), 0 = no reply (timeout)[m
[32m+[m[32mint rtl8139_arp_ping(uint8_t ip0, uint8_t ip1, uint8_t ip2, uint8_t ip3) {[m
[32m+[m[32m    if (!detected) return 0;[m
[32m+[m
[32m+[m[32m    // Build ARP request packet (42 bytes)[m
[32m+[m[32m    // Ethernet header (14) + ARP payload (28) = 42[m
[32m+[m[32m    uint8_t pkt[64]; // pad to minimum Ethernet frame[m
[32m+[m[32m    for (int i = 0; i < 64; i++) pkt[i] = 0;[m
[32m+[m
[32m+[m[32m    // --- Ethernet Header ---[m
[32m+[m[32m    // Destination: broadcast FF:FF:FF:FF:FF:FF[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[i] = 0xFF;[m
[32m+[m[32m    // Source: our MAC[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[6 + i] = mac_addr[i];[m
[32m+[m[32m    // EtherType: ARP (0x0806)[m
[32m+[m[32m    pkt[12] = 0x08;[m
[32m+[m[32m    pkt[13] = 0x06;[m
[32m+[m
[32m+[m[32m    // --- ARP Payload ---[m
[32m+[m[32m    // Hardware type: Ethernet (1)[m
[32m+[m[32m    pkt[14] = 0x00; pkt[15] = 0x01;[m
[32m+[m[32m    // Protocol type: IPv4 (0x0800)[m
[32m+[m[32m    pkt[16] = 0x08; pkt[17] = 0x00;[m
[32m+[m[32m    // Hardware size: 6[m
[32m+[m[32m    pkt[18] = 6;[m
[32m+[m[32m    // Protocol size: 4[m
[32m+[m[32m    pkt[19] = 4;[m
[32m+[m[32m    // Opcode: ARP Request (1)[m
[32m+[m[32m    pkt[20] = 0x00; pkt[21] = 0x01;[m
[32m+[m[32m    // Sender MAC[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[22 + i] = mac_addr[i];[m
[32m+[m[32m    // Sender IP: 10.0.2.15 (QEMU default guest IP)[m
[32m+[m[32m    pkt[28] = 10; pkt[29] = 0; pkt[30] = 2; pkt[31] = 15;[m
[32m+[m[32m    // Target MAC: 00:00:00:00:00:00 (unknown)[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[32 + i] = 0x00;[m
[32m+[m[32m    // Target IP[m
[32m+[m[32m    pkt[38] = ip0; pkt[39] = ip1; pkt[40] = ip2; pkt[41] = ip3;[m
[32m+[m
[32m+[m[32m    // Clear any pending received packets / ISR[m
[32m+[m[32m    outw(io_addr + REG_ISR, 0xFFFF);[m
[32m+[m
[32m+[m[32m    // Send the ARP request[m
[32m+[m[32m    if (!rtl8139_send_packet(pkt, 64)) return 0;[m
[32m+[m
[32m+[m[32m    // Wait for ARP reply (up to 2 seconds = 200 ticks at 100Hz)[m
[32m+[m[32m    uint8_t reply[256];[m
[32m+[m[32m    uint64_t start = get_tick_count();[m
[32m+[m[32m    while ((get_tick_count() - start) < 200) {[m
[32m+[m[32m        int len = rtl8139_check_rx(reply, 256);[m
[32m+[m[32m        if (len >= 42) {[m
[32m+[m[32m            // Check if this is an ARP reply[m
[32m+[m[32m            // EtherType at offset 12-13: 0x0806[m
[32m+[m[32m            if (reply[12] == 0x08 && reply[13] == 0x06) {[m
[32m+[m[32m                // ARP opcode at offset 20-21: 0x0002 = reply[m
[32m+[m[32m                if (reply[20] == 0x00 && reply[21] == 0x02) {[m
[32m+[m[32m                    // Check sender IP matches our target[m
[32m+[m[32m                    if (reply[28] == ip0 && reply[29] == ip1 &&[m
[32m+[m[32m                        reply[30] == ip2 && reply[31] == ip3) {[m
[32m+[m[32m                        return 1; // Success! Got ARP reply[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        // Small delay before checking again[m
[32m+[m[32m        asm volatile("hlt");[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return 0; // Timeout, no reply[m
[32m+[m[32m}[m
[1mdiff --git a/src/impl/kernel/main.c b/src/impl/kernel/main.c[m
[1mindex 91e8c68..5a5f555 100644[m
[1m--- a/src/impl/kernel/main.c[m
[1m+++ b/src/impl/kernel/main.c[m
[36m@@ -21,6 +21,7 @@[m
 [m
 // --- GUI STATE ---[m
 int current_app = APP_HOME;[m
[32m+[m[32m<<<<<<< Updated upstream[m
 // Increased buffer size to 64KB for "no limit" feel[m
 char notepad_buffer[65536]; [m
 int notepad_cursor = 0;[m
[36m@@ -169,6 +170,132 @@[m [mvoid delete_char_back() {[m
         notepad_cursor--;[m
     }[m
 }[m
[32m+[m[32m=======[m
[32m+[m[32mbool request_redraw = true;[m
[32m+[m
[32m+[m[32m// --- NOTEPAD STATE ---[m
[32m+[m[32m#define NOTE_BUF_SIZE 65536[m
[32m+[m[32mchar notepad_buffer[NOTE_BUF_SIZE];[m
[32m+[m[32mint note_len = 0;           // total chars in buffer[m
[32m+[m[32mint note_pos = 0;           // cursor position (insertion point)[m
[32m+[m[32mint note_sel = -1;          // selection anchor (-1 = no selection)[m
[32m+[m[32mint note_scroll_y = 0;      // scroll offset in lines[m
[32m+[m[32mint note_total_lines = 1;   // cached total line count[m
[32m+[m[32mint note_visible_lines = 1; // cached visible line count[m
[32m+[m[32mbool note_sb_dragging = false; // scrollbar thumb dragging[m
[32m+[m[32mint note_sb_drag_offset = 0;   // offset within thumb when drag started[m
[32m+[m[32mchar note_clipboard[NOTE_BUF_SIZE];[m
[32m+[m[32mint note_clip_len = 0;[m
[32m+[m
[32m+[m[32m// Helper: get selection range (ordered)[m
[32m+[m[32mstatic void note_get_sel(int* start, int* end) {[m
[32m+[m[32m    if (note_sel < 0) { *start = *end = note_pos; return; }[m
[32m+[m[32m    if (note_sel < note_pos) { *start = note_sel; *end = note_pos; }[m
[32m+[m[32m    else { *start = note_pos; *end = note_sel; }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Delete range [start, end) from buffer[m
[32m+[m[32mstatic void note_delete_range(int start, int end) {[m
[32m+[m[32m    if (start >= end) return;[m
[32m+[m[32m    int rem = end - start;[m
[32m+[m[32m    for (int i = end; i <= note_len; i++) notepad_buffer[i - rem] = notepad_buffer[i];[m
[32m+[m[32m    note_len -= rem;[m
[32m+[m[32m    note_pos = start;[m
[32m+[m[32m    note_sel = -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Insert string at note_pos[m
[32m+[m[32mstatic void note_insert(const char* s, int slen) {[m
[32m+[m[32m    if (note_len + slen >= NOTE_BUF_SIZE - 1) slen = NOTE_BUF_SIZE - 1 - note_len;[m
[32m+[m[32m    if (slen <= 0) return;[m
[32m+[m[32m    // Shift right[m
[32m+[m[32m    for (int i = note_len; i >= note_pos; i--) notepad_buffer[i + slen] = notepad_buffer[i];[m
[32m+[m[32m    for (int i = 0; i < slen; i++) notepad_buffer[note_pos + i] = s[i];[m
[32m+[m[32m    note_len += slen;[m
[32m+[m[32m    note_pos += slen;[m
[32m+[m[32m    note_sel = -1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Is char a word boundary?[m
[32m+[m[32mstatic int is_word_char(char c) {[m
[32m+[m[32m    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_';[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Move left by one word[m
[32m+[m[32mstatic int word_left(int pos) {[m
[32m+[m[32m    if (pos <= 0) return 0;[m
[32m+[m[32m    pos--;[m
[32m+[m[32m    while (pos > 0 && !is_word_char(notepad_buffer[pos])) pos--;[m
[32m+[m[32m    while (pos > 0 && is_word_char(notepad_buffer[pos - 1])) pos--;[m
[32m+[m[32m    return pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Move right by one word[m
[32m+[m[32mstatic int word_right(int pos) {[m
[32m+[m[32m    if (pos >= note_len) return note_len;[m
[32m+[m[32m    while (pos < note_len && !is_word_char(notepad_buffer[pos])) pos++;[m
[32m+[m[32m    while (pos < note_len && is_word_char(notepad_buffer[pos])) pos++;[m
[32m+[m[32m    return pos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Convert buffer position to line number[m
[32m+[m[32mstatic int note_pos_to_line(int pos, int chars_per_line) {[m
[32m+[m[32m    if (chars_per_line < 1) chars_per_line = 1;[m
[32m+[m[32m    int line = 0;[m
[32m+[m[32m    int col = 0;[m
[32m+[m[32m    for (int i = 0; i < pos && i < note_len; i++) {[m
[32m+[m[32m        if (notepad_buffer[i] == '\n') { line++; col = 0; }[m
[32m+[m[32m        else { col++; if (col >= chars_per_line) { line++; col = 0; } }[m
[32m+[m[32m    }[m
[32m+[m[32m    return line;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// --- SETTINGS STATE ---[m
[32m+[m[32mint setting_clock_24h = 1;      // 0 = 12h, 1 = 24h[m
[32m+[m[32mint setting_theme = 0;          // 0 = Light, 1 = Dark, 2 = Blue, 3 = Green, 4 = Orange, 5 = Yellow[m
[32m+[m[32mint setting_show_seconds = 0;   // 0 = off, 1 = on[m
[32m+[m[32mint setting_show_date = 1;      // 0 = off, 1 = on[m
[32m+[m[32mint settings_category = 0;      // 0=General, 1=Appearance, 2=Clock, 3=Network, 4=About[m
[32m+[m[32mint setting_timezone = 0;       // offset in hours from UTC (-12 to +14), stored as index into tz table[m
[32m+[m[32mint net_test_running = 0;       // 0=idle, 1=testing, 2=passed, 3=failed[m
[32m+[m[32mint setting_mouse_speed = 1;    // 0=Slow, 1=Normal, 2=Fast[m
[32m+[m[32mint setting_cursor_blink = 1;   // 0=off, 1=on[m
[32m+[m[32mint setting_word_wrap = 1;      // 0=off, 1=on[m
[32m+[m[32mint setting_line_numbers = 0;   // 0=off, 1=on[m
[32m+[m[32mint setting_tab_size = 4;       // 2 or 4[m
[32m+[m
[32m+[m[32m// Timezone offsets (hours from UTC)[m
[32m+[m[32mstatic const int tz_offsets[] = { -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };[m
[32m+[m[32mstatic const char* tz_labels[] = {[m
[32m+[m[32m    "UTC-12", "UTC-11", "UTC-10", "UTC-9", "UTC-8", "UTC-7", "UTC-6", "UTC-5",[m
[32m+[m[32m    "UTC-4", "UTC-3", "UTC-2", "UTC-1", "UTC+0", "UTC+1", "UTC+2", "UTC+3",[m
[32m+[m[32m    "UTC+4", "UTC+5", "UTC+6", "UTC+7", "UTC+8", "UTC+9", "UTC+10", "UTC+11",[m
[32m+[m[32m    "UTC+12", "UTC+13", "UTC+14"[m
[32m+[m[32m};[m
[32m+[m[32m#define TZ_COUNT 27[m
[32m+[m[32m#define TZ_DEFAULT 12  // UTC+0[m
[32m+[m
[32m+[m[32m// Theme color sets: {bg, text, sidebar, select}[m
[32m+[m[32mstatic uint32_t themes[][4] = {[m
[32m+[m[32m    {0xFFFFFFFF, 0xFF000000, 0xFFDDDDDD, 0xFFAAAAAA}, // Light[m
[32m+[m[32m    {0xFF1E1E1E, 0xFFE0E0E0, 0xFF2D2D2D, 0xFF444444}, // Dark[m[41m [m
[32m+[m[32m    {0xFFE8F0FE, 0xFF1A237E, 0xFFBBDEFB, 0xFF90CAF9}, // Blue[m
[32m+[m[32m    {0xFFE8F5E9, 0xFF1B5E20, 0xFFC8E6C9, 0xFFA5D6A7}, // Green[m
[32m+[m[32m    {0xFFFFF3E0, 0xFFBF360C, 0xFFFFE0B2, 0xFFFFCC80}, // Orange[m
[32m+[m[32m    {0xFFFFFDE7, 0xFFF57F17, 0xFFFFF9C4, 0xFFFFF176}, // Yellow[m
[32m+[m[32m};[m
[32m+[m[32m#define THEME_COUNT 6[m
[32m+[m[32mstatic const char* theme_names[] = { "Light", "Dark", "Blue", "Green", "Orange", "Yellow" };[m
[32m+[m
[32m+[m[32mstatic uint32_t get_bg(void)      { return themes[setting_theme][0]; }[m
[32m+[m[32mstatic uint32_t get_text(void)    { return themes[setting_theme][1]; }[m
[32m+[m[32mstatic uint32_t get_sidebar(void) { return themes[setting_theme][2]; }[m
[32m+[m[32mstatic uint32_t get_select(void)  { return themes[setting_theme][3]; }[m
[32m+[m
[32m+[m[32m// Cursor dimensions must match framebuffer_draw_cursor[m
[32m+[m[32m#define CURSOR_W 12[m
[32m+[m[32m#define CURSOR_H 16[m
[32m+[m[32m>>>>>>> Stashed changes[m
 [m
 // --- HELPERS ---[m
 [m
[36m@@ -177,18 +304,17 @@[m [mvoid print_2digits(int val, int x, int y, int scale) {[m
     buf[0] = '0' + (val / 10);[m
     buf[1] = '0' + (val % 10);[m
     buf[2] = 0;[m
[
[33mcommit 1e06f7a642645616c5d063ea7e4e786801832b2e[m
Author: Rak√©tapingvin <160329754+Raketapingvin@users.noreply.github.com>
Date:   Wed Feb 18 20:24:57 2026 +0100

    SETTINGS & CTR, NETWORK FIX
    
    Basic settings, theme added, scrollbar
    FIXED:
    Notepad key shortcuts and arrow moving.
    
    //UTC +1// 02/18/2026

[1mdiff --git a/Makefile b/Makefile[m
[1mindex 818ef75..48d894b 100644[m
[1m--- a/Makefile[m
[1m+++ b/Makefile[m
[36m@@ -24,4 +24,4 @@[m [mbuild-x86_64: $(x86_64_object_files)[m
 [m
 .PHONY: run[m
 run:[m
[31m-	qemu-system-x86_64 -cdrom dist/x86_64/kernel.iso -device rtl8139 -audiodev pa,id=spk -machine pcspk-audiodev=spk -device piix3-usb-uhci -drive file=disk.img,format=raw,index=0,media=disk[m
[32m+[m	[32mqemu-system-x86_64 -cdrom dist/x86_64/kernel.iso -netdev user,id=net0 -device rtl8139,netdev=net0 -audiodev pa,id=spk -machine pcspk-audiodev=spk -device piix3-usb-uhci -drive file=disk.img,format=raw,index=0,media=disk[m
[1mdiff --git a/src/impl/kernel/drivers/framebuffer.c b/src/impl/kernel/drivers/framebuffer.c[m
[1mindex 002dd81..761e570 100644[m
[1m--- a/src/impl/kernel/drivers/framebuffer.c[m
[1m+++ b/src/impl/kernel/drivers/framebuffer.c[m
[36m@@ -58,23 +58,78 @@[m [muint32_t framebuffer_get_pixel(uint32_t x, uint32_t y) {[m
     return *pixel;[m
 }[m
 [m
[32m+[m[32m<<<<<<< Updated upstream[m
[32m+[m[32m=======[m
[32m+[m[32mvoid framebuffer_swap(void) {[m
[32m+[m[32m    if (fb.base_address == 0 || fb.buffer_size == 0 || !dirty) return;[m
[32m+[m
[32m+[m[32m    // Only copy the dirty rectangle to VRAM[m
[32m+[m[32m    uint32_t x = dirty_x1;[m
[32m+[m[32m    uint32_t y = dirty_y1;[m
[32m+[m[32m    uint32_t w = dirty_x2 - dirty_x1 + 1;[m
[32m+[m[32m    uint32_t h = dirty_y2 - dirty_y1 + 1;[m
[32m+[m
[32m+[m[32m    for (uint32_t row = y; row < y + h; row++) {[m
[32m+[m[32m        uint64_t* dst = (uint64_t*)((uint8_t*)fb.base_address + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint64_t* src = (uint64_t*)(back_buffer + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint32_t qwords = ((w + (x & 1) + 1) / 2);[m
[32m+[m[32m        for (uint32_t i = 0; i < qwords; i++) {[m
[32m+[m[32m            dst[i] = src[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    dirty_reset();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid framebuffer_blit_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h) {[m
[32m+[m[32m    if (fb.base_address == 0) return;[m
[32m+[m
[32m+[m[32m    // Clamp to screen bounds[m
[32m+[m[32m    if (x >= fb.width || y >= fb.height) return;[m
[32m+[m[32m    if (x + w > fb.width) w = fb.width - x;[m
[32m+[m[32m    if (y + h > fb.height) h = fb.height - y;[m
[32m+[m
[32m+[m[32m    // Copy rectangle from back buffer to video memory using 64-bit writes[m
[32m+[m[32m    for (uint32_t row = y; row < y + h; row++) {[m
[32m+[m[32m        uint64_t* dst = (uint64_t*)((uint8_t*)fb.base_address + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint64_t* src = (uint64_t*)(back_buffer + row * fb.pitch + (x & ~1) * 4);[m
[32m+[m[32m        uint32_t qwords = ((w + (x & 1) + 1) / 2);[m
[32m+[m[32m        for (uint32_t i = 0; i < qwords; i++) {[m
[32m+[m[32m            dst[i] = src[i];[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m>>>>>>> Stashed changes[m
 void framebuffer_clear(uint32_t color) {[m
     if (fb.base_address == 0) return;[m
     [m
[31m-    // Naive clear[m
     for (uint32_t y = 0; y < fb.height; y++) {[m
[32m+[m[32m        uint32_t* row = (uint32_t*)(back_buffer + y * fb.pitch);[m
         for (uint32_t x = 0; x < fb.width; x++) {[m
[31m-            framebuffer_put_pixel(x, y, color);[m
[32m+[m[32m            row[x] = color;[m
         }[m
     }[m
[32m+[m[32m    dirty_mark(0, 0);[m
[32m+[m[32m    dirty_mark(fb.width - 1, fb.height - 1);[m
 }[m
 [m
 void framebuffer_draw_rect(uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {[m
[31m-    for (uint32_t i = 0; i < h; i++) {[m
[31m-        for (uint32_t j = 0; j < w; j++) {[m
[31m-            framebuffer_put_pixel(x + j, y + i, color);[m
[32m+[m[32m    if (fb.base_address == 0 || w == 0 || h == 0) return;[m
[32m+[m
[32m+[m[32m    // Clamp to screen bounds[m
[32m+[m[32m    if (x >= fb.width || y >= fb.height) return;[m
[32m+[m[32m    if (x + w > fb.width) w = fb.width - x;[m
[32m+[m[32m    if (y + h > fb.height) h = fb.height - y;[m
[32m+[m
[32m+[m[32m    for (uint32_t row = 0; row < h; row++) {[m
[32m+[m[32m        uint32_t* dst = (uint32_t*)(back_buffer + (y + row) * fb.pitch + x * 4);[m
[32m+[m[32m        for (uint32_t col = 0; col < w; col++) {[m
[32m+[m[32m            dst[col] = color;[m
         }[m
     }[m
[32m+[m[32m    dirty_mark(x, y);[m
[32m+[m[32m    dirty_mark(x + w - 1, y + h - 1);[m
 }[m
 [m
 void framebuffer_draw_cursor(uint32_t x, uint32_t y) {[m
[1mdiff --git a/src/impl/kernel/drivers/mouse.c b/src/impl/kernel/drivers/mouse.c[m
[1mindex 0eaa2a0..4369058 100644[m
[1m--- a/src/impl/kernel/drivers/mouse.c[m
[1m+++ b/src/impl/kernel/drivers/mouse.c[m
[36m@@ -38,10 +38,22 @@[m [muint8_t mouse_read_ack() {[m
     return inb(MOUSE_PORT_DATA);[m
 }[m
 [m
[32m+[m[32m// Mouse speed: 0=slow(0.5x), 1=normal(1x), 2=fast(2x)[m
[32m+[m[32mvolatile int mouse_speed_setting = 1;[m
[32m+[m
 static void mouse_process_packet() {[m
     uint8_t flags = mouse_byte[0];[m
[31m-    int8_t x_rel = (int8_t) mouse_byte[1];[m
[31m-    int8_t y_rel = (int8_t) mouse_byte[2];[m
[32m+[m[32m    int32_t x_rel = (int8_t) mouse_byte[1];[m
[32m+[m[32m    int32_t y_rel = (int8_t) mouse_byte[2];[m
[32m+[m
[32m+[m[32m    // Apply speed multiplier[m
[32m+[m[32m    if (mouse_speed_setting == 0) {[m
[32m+[m[32m        x_rel = x_rel / 2;[m
[32m+[m[32m        y_rel = y_rel / 2;[m
[32m+[m[32m    } else if (mouse_speed_setting == 2) {[m
[32m+[m[32m        x_rel = x_rel * 2;[m
[32m+[m[32m        y_rel = y_rel * 2;[m
[32m+[m[32m    }[m
 [m
     mouse_state.x += x_rel;[m
     mouse_state.y -= y_rel;[m
[1mdiff --git a/src/impl/kernel/drivers/rtl8139.c b/src/impl/kernel/drivers/rtl8139.c[m
[1mindex ff21c2b..06e9341 100644[m
[1m--- a/src/impl/kernel/drivers/rtl8139.c[m
[1m+++ b/src/impl/kernel/drivers/rtl8139.c[m
[36m@@ -2,11 +2,12 @@[m
 #include "drivers/pci.h"[m
 #include "util/io.h"[m
 #include "drivers/framebuffer.h"[m
[32m+[m[32m#include "cpu/timer.h"[m
 [m
 #define RTL8139_VENDOR_ID 0x10EC[m
 #define RTL8139_DEVICE_ID 0x8139[m
 [m
[31m-#define RX_BUF_SIZE 8192 + 16 + 1500[m
[32m+[m[32m#define RX_BUF_SIZE (8192 + 16 + 1500)[m
 [m
 // Registers[m
 #define REG_MAC0 0x00[m
[36m@@ -15,25 +16,32 @@[m
 #define REG_TXADDR0 0x20[m
 #define REG_RXBUF 0x30[m
 #define REG_CMD 0x37[m
[31m-#define REG_CAPR 0x38 [m
[32m+[m[32m#define REG_CAPR 0x38[m
[32m+[m[32m#define REG_CBR  0x3A  // Current Buffer address (read pointer for hw)[m
 #define REG_IMR 0x3C // Interrupt Mask Register[m
 #define REG_ISR 0x3E // Interrupt Status Register[m
 #define REG_TCR 0x40 // Transmit Config[m
 #define REG_RCR 0x44 // Receive Config[m
 #define REG_CONFIG1 0x52[m
 [m
[31m-uint32_t io_addr;[m
[31m-uint8_t rx_buffer[RX_BUF_SIZE];[m
[31m-uint8_t mac_addr[6];[m
[32m+[m[32mstatic uint32_t io_addr;[m
[32m+[m[32mstatic int detected = 0;[m
[32m+[m[32mstatic uint8_t rx_buffer[RX_BUF_SIZE] __attribute__((aligned(4)));[m
[32m+[m[32mstatic uint8_t mac_addr[6];[m
[32m+[m[32mstatic uint8_t tx_buf[4][2048] __attribute__((aligned(4)));[m
[32m+[m[32mstatic int cur_tx = 0;[m
[32m+[m[32mstatic uint16_t rx_read_ptr = 0;[m
 [m
 void rtl8139_init() {[m
     struct PciDevice pci_dev = pci_get_device(RTL8139_VENDOR_ID, RTL8139_DEVICE_ID);[m
     [m
     if (pci_dev.vendor_id == 0) {[m
[31m-        // print_str("RTL8139 not found!\n");[m
[32m+[m[32m        detected = 0;[m
         return;[m
     }[m
     [m
[32m+[m[32m    detected = 1;[m
[32m+[m
     // Enable Bus Mastering[m
     pci_enable_bus_mastering(pci_dev);[m
     [m
[36m@@ -60,6 +68,172 @@[m [mvoid rtl8139_init() {[m
     // Enable RE (Receive) and TE (Transmit)[m
     outb(io_addr + REG_CMD, 0x0C);[m
     [m
[32m+[m[32m    // Read MAC address[m
[32m+[m[32m    for (int i = 0; i < 6; i++) {[m
[32m+[m[32m        mac_addr[i] = inb(io_addr + REG_MAC0 + i);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Init TX descriptors[m
[32m+[m[32m    cur_tx = 0;[m
[32m+[m[32m    rx_read_ptr = 0;[m
[32m+[m
     // Draw green square to indicate success[m
     framebuffer_draw_rect(0, 0, 50, 50, 0xFF00FF00);[m
 }[m
[32m+[m
[32m+[m[32mint rtl8139_is_detected() {[m
[32m+[m[32m    return detected;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid rtl8139_get_mac(uint8_t* out) {[m
[32m+[m[32m    for (int i = 0; i < 6; i++) {[m
[32m+[m[32m        out[i] = mac_addr[i];[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Send a raw Ethernet frame. Returns 1 on success, 0 on failure.[m
[32m+[m[32mint rtl8139_send_packet(void* data, uint32_t len) {[m
[32m+[m[32m    if (!detected || len > 1792) return 0;[m
[32m+[m
[32m+[m[32m    // Copy packet data into current TX buffer[m
[32m+[m[32m    uint8_t* src = (uint8_t*)data;[m
[32m+[m[32m    for (uint32_t i = 0; i < len; i++) {[m
[32m+[m[32m        tx_buf[cur_tx][i] = src[i];[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Tell the NIC where the buffer is and how big[m
[32m+[m[32m    outl(io_addr + REG_TXADDR0 + cur_tx * 4, (uint32_t)(uint64_t)tx_buf[cur_tx]);[m
[32m+[m[32m    // Size in bits 0-12, clear OWN bit (bit 13) to start transmission[m
[32m+[m[32m    outl(io_addr + REG_TXSTATUS0 + cur_tx * 4, len & 0x1FFF);[m
[32m+[m
[32m+[m[32m    // Wait for TOK (Transmit OK, bit 15) or timeout[m
[32m+[m[32m    uint64_t start = get_tick_count();[m
[32m+[m[32m    while (1) {[m
[32m+[m[32m        uint32_t status = inl(io_addr + REG_TXSTATUS0 + cur_tx * 4);[m
[32m+[m[32m        if (status & (1 << 15)) break;  // TOK - transmit OK[m
[32m+[m[32m        if (status & (1 << 14)) break;  // TUN - transmit FIFO underrun (still sent in QEMU)[m
[32m+[m[32m        if ((get_tick_count() - start) > 50) return 0; // 500ms timeout[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    cur_tx = (cur_tx + 1) % 4;[m
[32m+[m[32m    return 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Check if any packet has been received. Returns length or 0.[m
[32m+[m[32mstatic int rtl8139_check_rx(uint8_t* out_buf, int max_len) {[m
[32m+[m[32m    if (!detected) return 0;[m
[32m+[m
[32m+[m[32m    // Check if buffer is empty[m
[32m+[m[32m    uint8_t cmd = inb(io_addr + REG_CMD);[m
[32m+[m[32m    if (cmd & 0x01) {[m
[32m+[m[32m        // Buffer empty bit is set, nothing to read[m
[32m+[m[32m        // Actually bit 0 of CMD is "Buffer Empty" when read[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Check ISR for ROK[m
[32m+[m[32m    uint16_t isr = inw(io_addr + REG_ISR);[m
[32m+[m[32m    if (!(isr & 0x01)) return 0; // No packet received[m
[32m+[m
[32m+[m[32m    // Clear ROK[m
[32m+[m[32m    outw(io_addr + REG_ISR, 0x01);[m
[32m+[m
[32m+[m[32m    // Read packet header from rx_buffer at rx_read_ptr[m
[32m+[m[32m    // Format: [status(16) | length(16) | packet_data...][m
[32m+[m[32m    uint16_t rx_status = *(uint16_t*)(rx_buffer + rx_read_ptr);[m
[32m+[m[32m    uint16_t rx_len    = *(uint16_t*)(rx_buffer + rx_read_ptr + 2);[m
[32m+[m
[32m+[m[32m    if (!(rx_status & 0x01)) return 0; // ROK bit not set in packet header[m
[32m+[m
[32m+[m[32m    // Sanity check length[m
[32m+[m[32m    if (rx_len < 8 || rx_len > 1792) {[m
[32m+[m[32m        // Bad packet, advance pointer[m
[32m+[m[32m        rx_read_ptr = (inw(io_addr + REG_CBR) + 16) & 0x1FFF;[m
[32m+[m[32m        outw(io_addr + REG_CAPR, rx_read_ptr - 16);[m
[32m+[m[32m        return 0;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Copy packet data (skip the 4-byte header)[m
[32m+[m[32m    int copy_len = rx_len - 4; // subtract CRC[m
[32m+[m[32m    if (copy_len > max_len) copy_len = max_len;[m
[32m+[m[32m    for (int i = 0; i < copy_len; i++) {[m
[32m+[m[32m        out_buf[i] = rx_buffer[(rx_read_ptr + 4 + i) % RX_BUF_SIZE];[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Advance read pointer (4-byte header + rx_len, aligned to 4 bytes + 4)[m
[32m+[m[32m    rx_read_ptr = (rx_read_ptr + rx_len + 4 + 3) & ~3;[m
[32m+[m[32m    rx_read_ptr %= RX_BUF_SIZE;[m
[32m+[m[32m    outw(io_addr + REG_CAPR, rx_read_ptr - 16);[m
[32m+[m
[32m+[m[32m    return copy_len;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Send an ARP "who-has" request to the given IP and wait for a reply.[m
[32m+[m[32m// Returns: 1 = got ARP reply (network works), 0 = no reply (timeout)[m
[32m+[m[32mint rtl8139_arp_ping(uint8_t ip0, uint8_t ip1, uint8_t ip2, uint8_t ip3) {[m
[32m+[m[32m    if (!detected) return 0;[m
[32m+[m
[32m+[m[32m    // Build ARP request packet (42 bytes)[m
[32m+[m[32m    // Ethernet header (14) + ARP payload (28) = 42[m
[32m+[m[32m    uint8_t pkt[64]; // pad to minimum Ethernet frame[m
[32m+[m[32m    for (int i = 0; i < 64; i++) pkt[i] = 0;[m
[32m+[m
[32m+[m[32m    // --- Ethernet Header ---[m
[32m+[m[32m    // Destination: broadcast FF:FF:FF:FF:FF:FF[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[i] = 0xFF;[m
[32m+[m[32m    // Source: our MAC[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[6 + i] = mac_addr[i];[m
[32m+[m[32m    // EtherType: ARP (0x0806)[m
[32m+[m[32m    pkt[12] = 0x08;[m
[32m+[m[32m    pkt[13] = 0x06;[m
[32m+[m
[32m+[m[32m    // --- ARP Payload ---[m
[32m+[m[32m    // Hardware type: Ethernet (1)[m
[32m+[m[32m    pkt[14] = 0x00; pkt[15] = 0x01;[m
[32m+[m[32m    // Protocol type: IPv4 (0x0800)[m
[32m+[m[32m    pkt[16] = 0x08; pkt[17] = 0x00;[m
[32m+[m[32m    // Hardware size: 6[m
[32m+[m[32m    pkt[18] = 6;[m
[32m+[m[32m    // Protocol size: 4[m
[32m+[m[32m    pkt[19] = 4;[m
[32m+[m[32m    // Opcode: ARP Request (1)[m
[32m+[m[32m    pkt[20] = 0x00; pkt[21] = 0x01;[m
[32m+[m[32m    // Sender MAC[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[22 + i] = mac_addr[i];[m
[32m+[m[32m    // Sender IP: 10.0.2.15 (QEMU default guest IP)[m
[32m+[m[32m    pkt[28] = 10; pkt[29] = 0; pkt[30] = 2; pkt[31] = 15;[m
[32m+[m[32m    // Target MAC: 00:00:00:00:00:00 (unknown)[m
[32m+[m[32m    for (int i = 0; i < 6; i++) pkt[32 + i] = 0x00;[m
[32m+[m[32m    // Target IP[m
[32m+[m[32m    pkt[38] = ip0; pkt[39] = ip1; pkt[40] = ip2; pkt[41] = ip3;[m
[32m+[m
[32m+[m[32m    // Clear any pending received packets / ISR[m
[32m+[m[32m    outw(io_addr + REG_ISR, 0xFFFF);[m
[32m+[m
[32m+[m[32m    // Send the ARP request[m
[32m+[m[32m    if (!rtl8139_send_packet(pkt, 64)) return 0;[m
[32m+[m
[32m+[m[32m    // Wait for ARP reply (up to 2 seconds = 200 ticks at 100Hz)[m
[32m+[m[32m    uint8_t reply[256];[m
[32m+[m[32m    uint64_t start = get_tick_count();[m
[32m+[m[32m    while ((get_tick_count() - start) < 200) {[m
[32m+[m[32m        int len = rtl8139_check_rx(reply, 256);[m
[32m+[m[32m        if (len >= 42) {[m
[32m+[m[32m            // Check if this is an ARP reply[m
[32m+[m[32m            // EtherType at offset 12-13: 0x0806[m
[32m+[m[32m            if (reply[12] == 0x08 && reply[13] == 0x06) {[m
[32m+[m[32m                // ARP opcode at offset 20-21: 0x0002 = reply[m
[32m+[m[32m                if (reply[20] == 0x00 && reply[21] == 0x02) {[m
[32m+[m[32m                    // Check sender IP matches our target[m
[32m+[m[32m                    if (reply[28] == ip0 && reply[29] == ip1 &&[m
[32m+[m[32m                        reply[30] == ip2 && reply[31] == ip3) {[m
[32m+[m[32m                        return 1; // Success! Got ARP reply[m
[